#include "../environment.h"
#include "../grid.h"
#include "../constants.h"

// set shell and CBM parameters
static double n0    = 1.;         // cm-3:    CBM number density
static double rho0  = n0*mp_;     // g.cm-3:  comoving CBM mass density
static double rho1  = rho0*1.4e12; // g.cm-3:  comoving shell mass density
static double lfac1 = 100.;        //          shell initial Lorentz factor
static double lfac2 = lfac1*lfac1;// Lorentz factor squared
static double eta   = 1.e-3;      //          eta = p/(rho*c^2)
static double theta = 0.2;        // rad:     simulation angle
static double N     = 4.;         //          gaussian: sigma = rtail/N

// shell generated by initial release (const lfac and rho) at t0, continues until t1, then gaussian shutdown until t2
static double t0      = 0.;       // s:     time of explosion, shell generation begins
static double t1      = 100.;     // s:     initial release phase ends, gaussian phase begins
static double t2      = 250.;     // s:     gaussian phase ends, no more emission after t2
static double t_ini   = 400.;     // s:     start time of dynamic simulation

// set simulation boundary positions
static double rmin    = 50.;      // light-seconds, box lower boundary at t_ini
static double rmax    = 500.;     // light-seconds, box upper boundary at t_ini

// normalisation constants:
static double rhoNorm = rho0;                 // density normalised to CBM density
static double lNorm = c_;                     // distance normalised to c
static double vNorm = c_;                     // velocity normalised to c
static double pNorm = rhoNorm*vNorm*vNorm;    // pressure normalised to rho_CMB/c^2

// calculate shell radii
static double rfront  = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t0);      // cm:  initial shell outer radius
static double rback   = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t1-t0);   // cm:  initial shell inner radius
static double rtail_r = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t2-t0);   // cm:  initial shell tail end radius
static double rtail   = rback-rtail_r;                            // cm:  distance of tail end from back of shell
static double rfront_norm = rfront/lNorm;     // ls
static double rback_norm  = rback/lNorm;      // ls
static double rtail_norm  = rtail/lNorm;      // ls

void loadParams(s_par *par){

  par->tini      = t_ini;         // initial time
  par->ncell[x_] = 500;           // number of cells in r direction
  par->ncell[y_] = 1;             // number of cells in theta direction
  par->nmax      = 2500;           // max number of cells in MV direction
  par->ngst      = 2;             // number of ghost cells (?); probably don't change

}

int Grid::initialGeometry(){                              // loop across grid, calculate cell positions and grid spacing, add info to cell struct "c"

// grid defined in length units of light-seconds

  for (int j = 0; j < ncell[y_]; ++j){
    for (int i = 0; i < ncell[x_]; ++i){
      Cell *c = &Cinit[j][i];
      
      double r_ls  = (double) (rmax-rmin)*(i+0.5)/ncell[x_] + rmin;
      double dr_ls = (double) (rmax-rmin)/ncell[x_];

      c->G.x[x_]  = r_ls;
      c->G.dx[x_] = dr_ls;
      c->G.x[y_]  = theta/2.;
      c->G.dx[y_] = theta;

      c->computeAllGeom();
    }
  }
  return 0;
}

int Grid::initialValues(){

  double c2   = c_*c_;
  double p0   = eta*rho0*c2;                  // CBM pressure
  double p1   = eta*rho1*c2;                  // peak shell pressure
  
  if (GAMMA_ != 4./3.){
    printf("WARNING - Set GAMMA_ to 4./3.\n");
  }
  if (VI != 1.){
    printf("WARNING - Set VI to 1.\n");
  }

  // declare variables for initial setup integrals
  // NOTE: These are isotropic values. For the actual injection energy and mass, multiply by jet_solid_angle/4pi
  double Eiso = 0.;                           // initialise for energy calculation (integral)
  double Miso = 0.;                           // initialise for mass calculation (integral)
  double f0   = 0.;
  double f1   = 0.;
  double m0   = 0.;
  double m1   = 0.;
  double r0   = 0.;
  double r1   = 0.;

  // initialise grid
  for (int j = 0; j < ncell[F1]; ++j){
    for (int i = 0; i < ncell[MV]; ++i){
      Cell *c = &Cinit[j][i];

      double r = c->G.x[x_];                  // ls:  radial coordinate
      double th = c->G.x[y_];                 // rad: theta angular coordinate
      
      double v1 = sqrt(1.-(1./lfac2))*c_;     // calculate peak shell outflow velocity at r in cm.s-1
      //printf("r = %e\t rtail = %e\t rback = %e\t rfront = %e\n",r,rtail_norm,rback_norm,rfront_norm);
      if (rback_norm-rtail_norm < r and r < rfront_norm){   // if in the shell
        c->S.prim[TR1] = 1.;
        
        if (rback_norm-rtail_norm < r and r <= rback_norm){   // if in the shell tail
          double A        = (r - rback_norm)/(rtail_norm/N);
          double rho_tail = (rho1-rho0)*exp(-0.5*A*A)+rho0;   // calculate density at r in gaussian tail
          double p_tail   = eta*rho_tail*c2;                  // calculate pressure at r in gaussian tail
          double lfac_t   = (lfac1-1)*exp(-0.5*A*A)+1;        // calculate lorentz factor at r in gaussian tail
          double lfac_t2  = lfac_t*lfac_t;
          double v_tail   = sqrt(1.-(1./lfac_t2))*c_;         // calculate velocity at r in gaussian tail
          c->S.prim[RHO]  = rho_tail/rhoNorm;
          c->S.prim[PPP]  = p_tail/pNorm;
          c->S.prim[VV1]  = v_tail/vNorm;
          c->S.prim[VV2]  = 0.;
        }
        
        else{                                               // if in the shell main body
          c->S.prim[RHO] = rho1/rhoNorm;
          c->S.prim[PPP] = p1/pNorm;
          c->S.prim[VV1] = v1/vNorm;
          c->S.prim[VV2] = 0.;
        }        
      }

      else{
        c->S.prim[RHO] = rho0/rhoNorm;
        c->S.prim[VV1] = 0;
        c->S.prim[VV2] = 0;
        c->S.prim[PPP] = p0/pNorm;
        c->S.prim[TR1] = 2.;
      }
      
      // integrate energy
      double dens = c->S.prim[RHO]*rhoNorm;
      double vel  = c->S.prim[VV1]*vNorm;
      double rad  = r*lNorm;
      double lfac = 1./sqrt(1.-((vel*vel)/(c_*c_)));
      double Edot = dens*4*PI*(rad*rad)*vel*(lfac*lfac)*(c_*c_)*(1.+(eta*((GAMMA_/(GAMMA_-1.)-(1./(lfac*lfac))))));
      if(i == 0){
        r1 = rad;
        m1 = lfac*dens*4*PI*rad*rad;
        if (Edot == 0){
          f1 = 0;
        }
        else{
          f1 = Edot/vel;
        }
      }
      else{
        r0 = r1;
        f0 = f1;
        m0 = m1;
        r1 = rad;
        m1 = lfac*dens*4*PI*rad*rad;
        if (Edot == 0){
          f1 = 0;
        }
        else{
          f1 = Edot/vel;
        }
        double dr = r1-r0;
        Eiso += 0.5*(f0 + f1)*dr;
        Miso += 0.5*(m0 + m1)*dr;
      }

    }
  }
  printf("Eiso = %e\tMiso = %e\n",Eiso,Miso);
  return 0;
}


void Grid::userKinematics(){

  // setting lower and higher i boundary interface velocities
  // set Lorentz factor of boundary interface
  double vIn_lfac   = 100; // inner boundary
  double vOut_lfac  = 200; // outer boundary
  
  // calculate velocities
  double vIn        = sqrt(1.-(1./(vIn_lfac*vIn_lfac)))*c_/vNorm;
  double vOut       = sqrt(1.-(1./(vOut_lfac*vOut_lfac)))*c_/vNorm;     
  
  for (int j = 0; j < nde_nax[F1]; ++j){
    for (int n = 0; n <= ngst; ++n){
      int    iL = n;
      int    iR = ntrack[j]-2-n;
      Itot[j][iL].v = vIn;
      Itot[j][iR].v = vOut;
    }
  }
}

void Cell::userSourceTerms(double dt){

  // copied from Test_RT
  // // sources have to be expressed in terms of conserved variables
  // double y   = G.x[y_]; 
  // double dV  = G.dV;
  // double rho = S.prim[RHO];
  // double fg = -rho*g*dV*dt;

  // S.cons[SS1] += fg;

}

void Grid::userBoundaries(int it, double t){

  UNUSED(it);
  UNUSED(t);

}


int Grid::checkCellForRegrid(int j, int i){

  Cell c = Ctot[j][i];


  // manual settings
  int phase  = 1;      // 0: keep constant dr;  1: keep constant dr in shell, const. A.R. in external medium;   2: const. A.R. in all parts of fluid
  // start off in phase 0, to keep focus on the shell
  // when the forward shock is forming, which is expected at ~1e5 to 1e6 s, switch to phase 2
  // phase 2 is aimed to allow the grid to expand in front of the shell to capture the forward shock, while still watching the reverse shock in the shell
  // in phase 2, the simulation space should expand - introduce a difference between the boundary velocities to allow for this.
  // if the reverse shock finishes passing through the shell around when the forward shock launches, skip phase 2
  // in phase 3, the simulation should follow the forward shock, potentially leaving the shell behind

  // ej = shell, ejecta; xm = external medium
  // split and merge values are upper and lower bounds as fractions of the target. Tighter bounds will mean more time spent regridding
  
  // phase 1
  double ej_split_dl  = 2.;
  double ej_merge_dl  = 0.5;
  // double ej_target_dl = 4.5;
  double ej_target_dl = 0.9;
  double xm_split_dl  = 2.;
  double xm_merge_dl  = 0.5;
  // double xm_target_dl = 10.;
  double xm_target_dl = 0.9;

  // phase 2
  // double ej_split_dl  = 5.;
  // double ej_merge_dl  = 0.2;
  // double ej_target_dl = 4.5;
  // double xm_split_ar  = 5.;
  // double xm_merge_ar  = 0.1;
  // double xm_target_ar = 0.01;
  
  // phase 3
  // double ej_split_ar  = ;
  // double ej_merge_ar  = ;
  // double ej_target_ar = ;
  // double xm_split_ar  = ;
  // double xm_merge_ar  = ;
  // double xm_target_ar = ;

  // external medium settings
  double trac = c.S.prim[TR1];  // get tracer value
  double r   = c.G.x[r_];       // get cell radial coordinate
  double dr  = c.G.dx[r_];      // get cell radial spacing
  double dth = c.G.dx[t_];      // get cell angular spacing
  double ar  = dr / (r*dth);    // calculate cell aspect ratio

  if (trac < 1.5){                              // if in ejecta
    if (phase == 1 or phase == 2){              // while keeping const. dr in shell  
      if (dr > ej_split_dl * ej_target_dl) {    // if dl is big
        return(split_);                         // split
      }
      if (dr < ej_merge_dl * ej_target_dl) {    // if dl is small
        return(merge_);                         // merge
      }
    }
    // if (phase == 3){                            // if shell resolution is relaxed (no longer keeping constant dr) follow shell behaviour
    //   if (ar > ej_split_ar * ej_target_ar) {
    //     return(split_);
    //   }
    //   if (ar < ej_merge_ar * ej_target_ar) {
    //     return(merge_);
    //   }
    // }
  }

  if (trac >1.5){                               // if in external medium
    if (phase == 1){                            // while keeping const. dr in external medium
      if (dr > xm_split_dl * xm_target_dl) {    // if dl is big
        return(split_);                         // split
      }
      if (dr < xm_merge_dl * xm_target_dl) {    // if dl is small
        return(merge_);                         // merge
      }
    }
    // if (phase == 2 or phase == 3){                            // if shell resolution is relaxed (no longer keeping constant dr) follow shell behaviour
    //   if (ar > ej_split_ar * ej_target_ar) {
    //     return(split_);
    //   }
    //   if (ar < ej_merge_ar * ej_target_ar) {
    //     return(merge_);
    //   }
    // }
  }

  return(skip_);
}


void Cell::user_regridVal(double *res){
  // user function to find regrid victims
  // adapts the search to special target resolution requirements
  // depending on the tracer value
  
  UNUSED(*res);

}


void FluidState::cons2prim_user(double *rho, double *p, double *uu){

  UNUSED(uu);
  UNUSED(*rho);
  UNUSED(*p);

  return;

}














