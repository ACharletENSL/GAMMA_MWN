#include "../environment.h"
#include "../grid.h"
#include "../constants.h"

// set shell and CBM parameters
static double n0      = 1.;           // cm-3:    CBM number density
static double rho0    = n0*mp_;       // g.cm-3:  comoving CBM mass density
static double rho1    = rho0*1.e13;  // g.cm-3:  comoving shell mass density
static double lfac1   = 30.;         //          shell initial Lorentz factor
static double lfac2   = lfac1*lfac1;  // Lorentz factor squared
static double eta     = 1.e-3;        //          eta = p/(rho*c^2)
static double th_simu = (PI/32.)/500.;          // rad:     simulation angle
static double N       = 4.;           //          gaussian: sigma = rtail/N

// shell generated by initial release (const lfac and rho) at t0, continues until t1, then gaussian shutdown until t2
static double t0      = 0.;           // s:     time of explosion, shell generation begins
static double t1      = 90.;         // s:     initial release phase ends, gaussian phase begins
static double t2      = 100.;         // s:     gaussian phase ends, no more emission after t2
static double t_ini   = 200.;         // s:     start time of dynamic simulation

// set simulation boundary positions
static double rmin    = 50.;          // light-seconds, box lower boundary at t_ini
static double rmax    = 250.;         // light-seconds, box upper boundary at t_ini

// normalisation constants:
static double rhoNorm = rho0;                 // density normalised to CBM density
static double lNorm = c_;                     // distance normalised to c
static double vNorm = c_;                     // velocity normalised to c
static double pNorm = rhoNorm*vNorm*vNorm;    // pressure normalised to rho_CMB/c^2

// calculate shell radii
static double rfront  = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t0);      // cm:  initial shell outer radius
static double rback   = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t1-t0);   // cm:  initial shell inner radius
static double rtail_r = (sqrt(1.-(1./lfac2)))*c_*(t_ini-t2-t0);   // cm:  initial shell tail end radius
static double rtail   = rback-rtail_r;                            // cm:  distance of tail end from back of shell
static double rfront_norm = rfront/lNorm;     // ls
static double rback_norm  = rback/lNorm;      // ls
static double rtail_norm  = rtail/lNorm;      // ls

void loadParams(s_par *par){

  par->tini      = t_ini;             // initial time
  par->ncell[x_] = 1500;              // number of cells in r direction
  par->ncell[y_] = 1;               // number of cells in theta direction
  par->nmax      = 3000;              // max number of cells in MV direction
  par->ngst      = 2;                 // number of ghost cells (?); probably don't change

}

int Grid::initialGeometry(){                              // loop across grid, calculate cell positions and grid spacing, add info to cell struct "c"

// grid defined in length units of light-seconds

  double logrmin  = log(rmin);
  double logrmax  = log(rmax);
  double dlogr    = (logrmax - logrmin);
  
  for (int j = 0; j < ncell[y_]; ++j){
    for (int i = 0; i < ncell[x_]; ++i){
      Cell *c = &Cinit[j][i];
      
      double rlog   = (double) dlogr*(i+0.5)/ncell[x_] + logrmin;
      double rlogL  = (double) dlogr*(i  )/ncell[x_] + logrmin;
      double rlogR  = (double) dlogr*(i+1)/ncell[x_] + logrmin;
      double r_ls   = exp(rlog);
      double dr_ls  = exp(rlogR) - exp(rlogL);
      
      double th     = (double) th_simu*(j+0.5)/ncell[y_];
      double dth    = th_simu/ncell[y_];

      c->G.x[x_]    = r_ls;
      c->G.dx[x_]   = dr_ls;
      c->G.x[y_]    = th;
      c->G.dx[y_]   = dth;

      c->computeAllGeom();
    }
  }
  return 0;
}

int Grid::initialValues(){

  double c2   = c_*c_;
  double p0   = eta*rho0*c2;                  // CBM pressure
  double p1   = eta*rho1*c2;                  // peak shell pressure
  
  if (GAMMA_ != 4./3.){
    printf("WARNING - Set GAMMA_ to 4./3.\n");
  }
  if (VI != 1.){
    printf("WARNING - Set VI to 1.\n");
  }

  // declare variables for initial setup integrals
  // NOTE: These are isotropic values. For the actual injection energy and mass, multiply by jet_solid_angle/4pi
  double Eiso = 0.;                           // initialise for energy calculation (integral)
  double Miso = 0.;                           // initialise for mass calculation (integral)
  double f0   = 0.;
  double f1   = 0.;
  double m0   = 0.;
  double m1   = 0.;
  double r0   = 0.;
  double r1   = 0.;

  // initialise grid
  for (int j = 0; j < ncell[F1]; ++j){        // loop through cells along theta
    for (int i = 0; i < ncell[MV]; ++i){      // loop through cells along r
      Cell *c = &Cinit[j][i];

      double r = c->G.x[x_];                  // ls:  radial coordinate
      double th = c->G.x[y_];                 // rad: theta angular coordinate
      
      double v1 = sqrt(1.-(1./lfac2))*c_;     // calculate peak shell outflow velocity at r in cm.s-1
      //printf("r = %e\t rtail = %e\t rback = %e\t rfront = %e\n",r,rtail_norm,rback_norm,rfront_norm);
      if (rback_norm-rtail_norm < r and r < rfront_norm){   // if in the shell
        c->S.prim[TR1] = 1.;
        
        if (rback_norm-rtail_norm < r and r <= rback_norm){   // if in the shell tail
          double A        = (r - rback_norm)/(rtail_norm/N);
          //double rho_tail = (rho1-rho0)*exp(-0.5*A*A)+rho0;   // calculate density at r in gaussian tail
          double ln_rho_tail = log(rho1/rho0)*exp(-0.5*A*A)+log(rho0);   // calculate density at r in gaussian tail
          double rho_tail = exp(ln_rho_tail);
          double p_tail   = eta*rho_tail*c2;                  // calculate pressure at r in gaussian tail
          double lfac_t   = (lfac1-1)*exp(-0.5*A*A)+1;        // calculate lorentz factor at r in gaussian tail
          double lfac_t2  = lfac_t*lfac_t;
          double v_tail   = sqrt(1.-(1./lfac_t2))*c_;         // calculate velocity at r in gaussian tail
          c->S.prim[RHO]  = rho_tail/rhoNorm;
          c->S.prim[PPP]  = p_tail/pNorm;
          c->S.prim[VV1]  = v_tail/vNorm;
          c->S.prim[VV2]  = 0.;
        }
        
        else{                                               // if in the shell main body
          c->S.prim[RHO] = rho1/rhoNorm;
          c->S.prim[PPP] = p1/pNorm;
          c->S.prim[VV1] = v1/vNorm;
          c->S.prim[VV2] = 0.;
        }        
      }

      else{
        c->S.prim[RHO] = rho0/rhoNorm;
        c->S.prim[VV1] = 0;
        c->S.prim[VV2] = 0;
        c->S.prim[PPP] = p0/pNorm;
        c->S.prim[TR1] = 2.;
      }
      
      
      // integrate energy; only do integral along 1 track, otherwise this adds up all tracks in the integral giving a factor of Ntheta higher
      if (j == 0){                                          // if in first track
        double dens = c->S.prim[RHO]*rhoNorm;
        double vel  = c->S.prim[VV1]*vNorm;
        double rad  = r*lNorm;
        double lfac = 1./sqrt(1.-((vel*vel)/(c_*c_)));
        double Edot = dens*4*PI*(rad*rad)*vel*(lfac*lfac)*(c_*c_)*(1.+(eta*((GAMMA_/(GAMMA_-1.)-(1./(lfac*lfac))))));
      
        if(i == 0){
          r1 = rad;
          m1 = lfac*dens*4*PI*rad*rad;
          if (Edot == 0){
            f1 = 0;
          }
          else{
            f1 = Edot/vel;
          }
        }
        else{
          r0 = r1;
          f0 = f1;
          m0 = m1;
          r1 = rad;
          m1 = lfac*dens*4*PI*rad*rad;
          if (Edot == 0){
            f1 = 0;
          }
          else{
            f1 = Edot/vel;
          }
          double dr = r1-r0;
          Eiso += 0.5*(f0 + f1)*dr;
          Miso += 0.5*(m0 + m1)*dr;
        }
      }
    }
  }
  printf("Eiso = %e\tMiso = %e\n",Eiso,Miso);
  return 0;
}


void Grid::userKinematics(){

  // setting lower and higher i boundary interface velocities

  // set by boundary velocity:
  double vIn  = 0.75;
  double vOut = 1.05;


  // set by Lorentz factor:
  // double vIn_lfac   = 100; // inner boundary
  // double vOut_lfac  = 200; // outer boundary
  // double vIn        = sqrt(1.-(1./(vIn_lfac*vIn_lfac)))*c_/vNorm;
  // double vOut       = sqrt(1.-(1./(vOut_lfac*vOut_lfac)))*c_/vNorm;     
  
  for (int j = 0; j < nde_nax[F1]; ++j){
    for (int n = 0; n < ngst; ++n){
      int    iL = n;
      int    iR = ntrack[j]-2-n;
      Itot[j][iL].v = vIn;
      Itot[j][iR].v = vOut;
    }
  }
}

void Cell::userSourceTerms(double dt){

  UNUSED(dt);

}

void Grid::userBoundaries(int it, double t){

  UNUSED(it);
  UNUSED(t);

}


int Grid::checkCellForRegrid(int j, int i){

  Cell c = Ctot[j][i];

  // double trac = c.S.prim[TR1];           // get tracer value
  double r   = c.G.x[r_];                   // get cell radial coordinate
  double dr  = c.G.dx[r_];                  // get cell radial spacing
  double dth = c.G.dx[t_];                  // get cell angular spacing
  double ar  = dr / (r*dth);                // calculate cell aspect ratio
  
  // aspect ratio based regridding:
  // calculate target aspect ratio at radius r:
  // double sim_time   = 3.e7;                 // set expected simulation end time
  // double start_AR   = 10.;                  // set initial target aspect ratio
  // double end_AR     = 3.;                   // set target aspect ratio at expected end time
  // double target_AR  = start_AR - ((start_AR-end_AR)/sim_time)*r;
  // the above does not work - gives low resolution between start and end points
  // empirically found the following to work:

  //double y0         = 0.9863;
  double y0         = 1.0146;
  // double yM         = 70.23;
  double yM         = 3495.2;
  // double k          = 1.660;
  double k          = 2.790;
  double target_AR  = y0 + (yM-y0) * exp(-k*log10(r));

  //double target_AR  = 1.;

  double split_AR   = 5.;                   // set upper bound as ratio of target_AR
  double merge_AR   = 0.2;                  // set upper bound as ratio of target_AR

  if (ar > split_AR * target_AR) {          // if cell is too long for its width
      // return(split_);                       // split
  }
  if (ar < merge_AR * target_AR) {          // if cell is too short for its width
      return(merge_);                       // merge
  }
  return(skip_);
}


void Cell::user_regridVal(double *res){
  // user function to find regrid victims
  // adapts the search to special target resolution requirements
  // depending on the tracer value
  
  UNUSED(*res);

}


void FluidState::cons2prim_user(double *rho, double *p, double *uu){

  UNUSED(uu);
  UNUSED(*rho);
  UNUSED(*p);

  return;

}














